//import {Component, PureComponent} from 'react'
//return withSubscribe @ evtbus, @{} Component, PureComponent

export function withSubscribe(evtbus, Component) ::
  if 'function' !== typeof Component ::
    if Array.isArray @ Component ::
      return Component.map @ Comp =>
        withSubscribe @ evtbus, Comp
    else ::
      const res = {}
      for const [name, Comp] of Object.entries @ Component ::
        if 'function' === typeof Comp ::
          res[name] = withSubscribe @ evtbus, Comp
      return res

  const C = class extends Component ::
    subscribe(props) ::

    componentWillMount() ::
      super.componentWillMount()
      bindSubscriptions @ this
      this.evt_sink.emit('will_mount')

    componentDidMount() ::
      this.evt_sink.emit('did_mount')

    componentWillUnmount() ::
      this.evt_sink.emit('will_unmount').clear()

    get evt_sink() :: return evtbus.sink(this)

  C.prototype.evtbus = evtbus
  return C


export function bindSubscriptions(component, callback) ::
  if null == component.state ::
    component.state = {}

  const unwind = []
  component.evt_sink
    .on @ 'will_mount', mount
    .on @ 'will_unmount', unmount

  function unmount() ::
    for const unsub of unwind.splice @ 0, unwind.length ::
      unsub()

  function mount() ::
    const sub_state = callback
      ? callback.call(component, component.props, component)
      : component.subscribe(component.props)

    component.setState @ sub_state, function() ::
      for const [attr, sub] of Object.entries @ sub_state ::
        if null == sub || 'function' !== typeof sub.subscribe ::
          throw new TypeError @ `Subscription "${attr}" does not have a subscribe() function`

        unwind.push @ sub.subscribe @ false, v => ::
          component.setState @ prev =>
            v !== prev[attr] ? {[attr]: v} : null

