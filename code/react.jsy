export function withSubscribe(evtbus, Component) ::
  const C = class extends Component ::
    state = this.state || {}

    subscriptions(props) ::
    setSubscriptionState(sub_state, cleanup) ::
      if undefined !== cleanup ::
        Object.assign @ this.state, sub_state
        this.evt_sink.on @ 'cleanup', cleanup
      else ::
        this.setState(sub_state)

    componentWillMount() ::
      bindSubscriptions(this)

    componentWillUnmount(...args) ::
      this.evt_sink.emit('cleanup').clear()

    get evt_sink() :: return evtbus.sink(this)

  C.prototype.evtbus = evtbus
  return C


export function bindSubscriptions(component) ::
  const subscriptions = 'function' === typeof component.subscriptions
    ? component.subscriptions(component.props)
    : component.subscriptions

  if null == subscriptions :: return

  const sub_state={}, unwind=[]
  let q = null

  for const [attr, sub] of Object.entries @ subscriptions ::
    if null == sub || 'function' !== typeof sub.subscribe ::
      throw new TypeError @ `Subscription "${attr}" does not have a subscribe() function`

    unwind.push @
      sub.subscribe @ v => ::
        sub_state[attr] = v
        if null === q ::
          q = resolveNext()

  component.setSubscriptionState @ sub_state, unsubscribeAll

  function unsubscribeAll() ::
    for const unsub of unwind.splice @ 0, unwind.length ::
      unsub()

  // use promise resolution to debounce updates
  function resolveNext() ::
    return Promise.resolve().then @ () => ::
      component.setSubscriptionState @ sub_state
      q = null
